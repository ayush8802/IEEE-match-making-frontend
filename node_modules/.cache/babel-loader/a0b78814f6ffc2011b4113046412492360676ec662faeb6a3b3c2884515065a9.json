{"ast":null,"code":"/**\r\n * API Service\r\n * Centralized HTTP client with interceptors and error handling\r\n */\n\nimport axios from \"axios\";\nimport config from \"../config/api\";\nimport supabase from \"../config/supabase\";\n\n/**\r\n * Create axios instance with base configuration\r\n */\nconst apiClient = axios.create({\n  baseURL: config.BASE_URL,\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  timeout: 30000 // 30 seconds\n});\n\n/**\r\n * Request interceptor - attach auth token\r\n */\napiClient.interceptors.request.use(async config => {\n  // Get current session\n  const {\n    data: {\n      session\n    }\n  } = await supabase.auth.getSession();\n\n  // Attach token if available\n  if (session !== null && session !== void 0 && session.access_token) {\n    config.headers.Authorization = `Bearer ${session.access_token}`;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n/**\r\n * Response interceptor - handle errors\r\n */\napiClient.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  var _error$response, _error$response2, _error$response2$data, _error$response2$data2, _error$response3, _error$response4;\n  const originalRequest = error.config;\n\n  // Handle 401 errors (token expired)\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // Try to refresh the session\n      const {\n        data: {\n          session\n        },\n        error: refreshError\n      } = await supabase.auth.refreshSession();\n      if (refreshError || !session) {\n        // Refresh failed, redirect to login\n        window.location.href = \"/\";\n        return Promise.reject(error);\n      }\n\n      // Retry the original request with new token\n      originalRequest.headers.Authorization = `Bearer ${session.access_token}`;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      // Refresh failed, redirect to login\n      window.location.href = \"/\";\n      return Promise.reject(error);\n    }\n  }\n\n  // Format error for better handling\n  const formattedError = {\n    message: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : (_error$response2$data2 = _error$response2$data.error) === null || _error$response2$data2 === void 0 ? void 0 : _error$response2$data2.message) || error.message || \"An error occurred\",\n    status: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status,\n    data: (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data\n  };\n  return Promise.reject(formattedError);\n});\n\n/**\r\n * Generic API request function with retry logic\r\n * @param {Function} requestFn - Function that returns a promise\r\n * @param {number} maxRetries - Maximum number of retries\r\n * @returns {Promise} Response data\r\n */\nexport async function apiRequest(requestFn, maxRetries = 2) {\n  let lastError;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const response = await requestFn();\n      return response.data;\n    } catch (error) {\n      lastError = error;\n\n      // Don't retry on client errors (4xx)\n      if (error.status && error.status >= 400 && error.status < 500) {\n        throw error;\n      }\n\n      // Wait before retrying (exponential backoff)\n      if (attempt < maxRetries) {\n        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s...\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  throw lastError;\n}\nexport default apiClient;","map":{"version":3,"names":["axios","config","supabase","apiClient","create","baseURL","BASE_URL","headers","timeout","interceptors","request","use","data","session","auth","getSession","access_token","Authorization","error","Promise","reject","response","_error$response","_error$response2","_error$response2$data","_error$response2$data2","_error$response3","_error$response4","originalRequest","status","_retry","refreshError","refreshSession","window","location","href","formattedError","message","apiRequest","requestFn","maxRetries","lastError","attempt","delay","Math","pow","resolve","setTimeout"],"sources":["D:/ieee match making/frontend/src/services/api.js"],"sourcesContent":["/**\r\n * API Service\r\n * Centralized HTTP client with interceptors and error handling\r\n */\r\n\r\nimport axios from \"axios\";\r\nimport config from \"../config/api\";\r\nimport supabase from \"../config/supabase\";\r\n\r\n/**\r\n * Create axios instance with base configuration\r\n */\r\nconst apiClient = axios.create({\r\n    baseURL: config.BASE_URL,\r\n    headers: {\r\n        \"Content-Type\": \"application/json\",\r\n    },\r\n    timeout: 30000, // 30 seconds\r\n});\r\n\r\n/**\r\n * Request interceptor - attach auth token\r\n */\r\napiClient.interceptors.request.use(\r\n    async (config) => {\r\n        // Get current session\r\n        const { data: { session } } = await supabase.auth.getSession();\r\n\r\n        // Attach token if available\r\n        if (session?.access_token) {\r\n            config.headers.Authorization = `Bearer ${session.access_token}`;\r\n        }\r\n\r\n        return config;\r\n    },\r\n    (error) => {\r\n        return Promise.reject(error);\r\n    }\r\n);\r\n\r\n/**\r\n * Response interceptor - handle errors\r\n */\r\napiClient.interceptors.response.use(\r\n    (response) => {\r\n        return response;\r\n    },\r\n    async (error) => {\r\n        const originalRequest = error.config;\r\n\r\n        // Handle 401 errors (token expired)\r\n        if (error.response?.status === 401 && !originalRequest._retry) {\r\n            originalRequest._retry = true;\r\n\r\n            try {\r\n                // Try to refresh the session\r\n                const { data: { session }, error: refreshError } = await supabase.auth.refreshSession();\r\n\r\n                if (refreshError || !session) {\r\n                    // Refresh failed, redirect to login\r\n                    window.location.href = \"/\";\r\n                    return Promise.reject(error);\r\n                }\r\n\r\n                // Retry the original request with new token\r\n                originalRequest.headers.Authorization = `Bearer ${session.access_token}`;\r\n                return apiClient(originalRequest);\r\n            } catch (refreshError) {\r\n                // Refresh failed, redirect to login\r\n                window.location.href = \"/\";\r\n                return Promise.reject(error);\r\n            }\r\n        }\r\n\r\n        // Format error for better handling\r\n        const formattedError = {\r\n            message: error.response?.data?.error?.message || error.message || \"An error occurred\",\r\n            status: error.response?.status,\r\n            data: error.response?.data,\r\n        };\r\n\r\n        return Promise.reject(formattedError);\r\n    }\r\n);\r\n\r\n/**\r\n * Generic API request function with retry logic\r\n * @param {Function} requestFn - Function that returns a promise\r\n * @param {number} maxRetries - Maximum number of retries\r\n * @returns {Promise} Response data\r\n */\r\nexport async function apiRequest(requestFn, maxRetries = 2) {\r\n    let lastError;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n        try {\r\n            const response = await requestFn();\r\n            return response.data;\r\n        } catch (error) {\r\n            lastError = error;\r\n\r\n            // Don't retry on client errors (4xx)\r\n            if (error.status && error.status >= 400 && error.status < 500) {\r\n                throw error;\r\n            }\r\n\r\n            // Wait before retrying (exponential backoff)\r\n            if (attempt < maxRetries) {\r\n                const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s...\r\n                await new Promise((resolve) => setTimeout(resolve, delay));\r\n            }\r\n        }\r\n    }\r\n\r\n    throw lastError;\r\n}\r\n\r\nexport default apiClient;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}